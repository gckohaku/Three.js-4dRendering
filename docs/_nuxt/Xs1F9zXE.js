var a=Object.defineProperty;var r=(i,e,s)=>e in i?a(i,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):i[e]=s;var t=(i,e,s)=>r(i,typeof e!="symbol"?e+"":e,s);const n=i=>i[0]<=i[1]?i:[i[1],i[0]];class d{constructor(){t(this,"data",[]);t(this,"size",0)}*[Symbol.iterator](){yield*this.data}*values(){yield*this}*keys(){yield*this}*entries(){for(const e of this.keys())yield[e,e]}add(e){if(this.has(e))return this;const s=n(e);return this.data.push(s),this.size++,this}clear(){this.data.splice(0),this.size=0}delete(e){const s=this.indexOf(e);return s===-1?!1:(this.data.splice(s,1),this.size--,!0)}has(e){return this.indexOf(e)!==-1}indexOf(e){const s=n(e);return this.data.findIndex(h=>s[0]===h[0]&&s[1]===h[1])}}class c{constructor(){t(this,"keyList",new d);t(this,"valueList",[])}get size(){return this.keyList.size}*keys(){yield*this.keyList}*values(){yield*this.valueList}*entries(){let e=0;for(const s of this.keys())yield[s,this.valueList[e]],e++}set(e,s){if(this.keyList.has(e)){const h=this.keyList.indexOf(e);this.valueList[h]=s}else this.keyList.add(e),this.valueList.push(s);return this.checkMatchKeyAndValueSize(),this}has(e){return this.keyList.has(e)}get(e){const s=this.keyList.indexOf(e);if(s!==-1)return this.valueList[s]}clear(){this.keyList.clear(),this.valueList.splice(0),this.checkMatchKeyAndValueSize()}delete(e){const s=this.keyList.indexOf(e);return s===-1?!1:(this.keyList.delete(e),this.valueList.splice(s,1),this.checkMatchKeyAndValueSize(),!0)}checkMatchKeyAndValueSize(){if(this.keyList.size!==this.valueList.length||this.valueList.length!==this.size)throw new Error(`CONTAIN DATA SIZE ERROR: mismatch key size, value size and this size
key size: ${this.keyList.size}
value size: ${this.valueList.length}
this size${this.size}`)}}export{d as A,c as a,n as c};
